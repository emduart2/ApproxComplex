--ex1 is the ideal that gives a hilbert burch resolution 
--assuming a syzygy of bidegree (0,1)
--case A=0
ex1=()-> (
p0=t^2*u;
p1=t^2*v;
p2=s*t*v;
m=random(R^2,R^1);
forms=matrix{{s*t*u,s*t*v}};
p3=forms*m+s^2*v;
test=ideal(p0,p1,p2,p3);
)


-- ex2 is the other case when we have a syzygy of bidegre (0,1)
-- case A !=0
ex2=()->(
xp0=t^2*u;
A=random(R^1,R^1);
A=A_(0,0);
p1=A*t^2*u+t^2*v;
p2=A*s*t*u+s*t*v;
m=random(R^2,R^1);
forms=matrix{{s*t*u,s*t*v}};
p3=forms*m+s^2*v;
test=ideal(p0,p1,p2,p3);
)

-- ex3 is the case when we have a syzygy of bidegree (1,0)
-- and the polynomial p is indecomposable
-- expect to get the full resolution


ex3=()->(
m=random(R^2,R^1);
forms=matrix{{t*u,t*v}};
p=forms*m+s*v;
p0=p*s;
p1=p*t;
m=random(R^3,R^1);
forms=matrix{{s*t*u,t^2*u,t^2*v}};
p2=forms*m;
m=random(R^3,R^1);
forms=matrix{{s*t*u,t^2*u,t^2*v}};
p3=forms*m;
test=ideal(p0,p1,p2,p3);
)

-- ex4 is the same as case ex3 except p is decomposable
ex4=()->(
p=t*u;
p0=s*p;
p1=t*p;
m=random(R^2,R^1);
forms=matrix{{s*t*v,t^2*v}};
p2=forms*m;
b3=random(R^1,R^1);
b3=b3_(0,0);
p3=s^2*v+b3*s*t*v;
I=ideal(p0,p1,p2,p3);
)

---- generic case
lolo=ideal(t,v);
lool=ideal(t,u);
ollo=ideal(s,v);
olol=ideal(s,u);

---- the code restest takes any ideal, computes a basis for it
--- in the desired bidegree i,j and gives back an ideal generated 
--- by 4 random polynomials of bidegree i,j
restest=(I,i,j)->(
M=super basis({i,j},I);
n=numgens source M;
ge= for i from 0 to 1 list apply(4,i->(random(R^4,R^n)*transpose M)_(i,0));
test=ideal(ge#0);
return test;
)

------- BASEPOINT FREE EXAMPLE -------------
--- this code takes a bidegree and gives me a basepoint free ideal
--- generated by bihomogenous polynomials of the same degree i,j.

blist=(i,j)->(
M=super basis({i,j},R);
n=numgens source M;
ge= for i from 0 to 1 list apply(4,i->(random(R^4,R^n)*transpose M)_(i,0));
test=ideal(ge#0);
)

------examples with a linear syzygy and basepoint free---------
-- this code takes a bidegree i,j and gives back an ideal with a linear syzygy
--- and generated by forms of degree i,g

blin=(i,j)->(
M=super basis({i,j},R);
n=numgens source M;
ges= apply(2,i->(random(R^2,R^n)*transpose M)_(i,0));
p2=ges#0;
p3=ges#1;
Mp=super basis({i,j-1},R);
np=numgens source Mp;
p= random(R^1,R^np)*transpose Mp;
test=ideal(p*u,p*v,p2,p3);
return test;
)


-------EXAMPLE WITH ONE RANDOM BASEPOINT
-------

onebpt=(i,j)->(
M=random(R^1,R^2);
forms=matrix{{s},{t}};
Lp=M*forms;
M=random(R^1,R^2);
forms=matrix{{u},{v}};
Lq=M*forms;
testo=ideal(Lp,Lq);
restest(testo,i,j)
)

------- Example with a prescribed number of basepoints
------k is equal to the number of basepoints and (a,b) is the bidegree

kbpts=(k)->(
i=0;
lst={};
while i<k
do(
M=random(R^1,R^2);
forms=matrix{{s},{t}};
Lp=M*forms;
M=random(R^1,R^2);
forms=matrix{{u},{v}};

Lq=M*forms;
testo=ideal(Lp,Lq);
lst=lst|{testo};
i=i+1;
);
I=lst_0;
j=1;
while j<k
do(
I=intersect(I,lst_j);
j=j+1;
);
return I;
)

------------ In this example we want to prescribe the points inside a  k x k complete intersection 
------------by writing the tuples of the points we are choosing
------------ 

grd=(k,tuples)->(
i=0;
lst1={};
lst2={};
L=1;
H=1;
while i<k
do(
M=random(R^1,R^2);
forms=matrix{{s},{t}};
Lp=(M*forms)_(0,0);
M=random(R^1,R^2);
forms=matrix{{u},{v}};
Lq=(M*forms)_(0,0);
lst1=lst1|{Lp};
L=L*Lp;
H=H*Lq;
lst2=lst2|{Lq};
i=i+1;
);
pts=for j from 0 to #tuples-1 list ideal(lst1_(tuples#j_0),lst2_(tuples#j_1));
I=pts_0;
j=1;
while j<#tuples
do(
    I=intersect(I,pts_j);
    j=j+1;
    );
return I;
)
------------ This example is when we assume the basepoint is of the form (1,0,1,0)

tibpt=(i,j)->(
M=super basis({i-1,j-1},R);
n=numgens source M;
f=apply(4,i->(M*random(R^n,R^4))_(0,0));
g=apply(4,i->(M*random(R^n,R^4))_(0,0));
p0=s^i*v+t*u*f_0+t*v*g_0;
p1=t*u*f_1+t*v*g_1;
p2=t*u*f_2+t*v*g_2;
p3=t*u*f_3+t*v*g_3;
syz1=matrix{{0,g_2*f_3-f_2*g_3,f_1*g_3-g_1*f_3,f_2*g_1-f_1*g_2}};
test=ideal(p0,p1,p2,p3);
)

------Test of things
------- modified generators
----- These examples are from the (2,1) case where I computed the resolutions
----- by rewriting the generators in a suitable way.
modgens0=()->(
L=apply(4,i->(super basis({1,1},R))*random(R^4,R^1));
test=ideal(s^2*v+t*L_0,t*L_1,t*L_2,t*L_3);
)

modgens1=()->(
L=apply(4,i->(matrix{{s*u,t*u,t*v}})*random(R^3,R^1));
test=ideal(s^2*v+t*L_0,s*t*v+t*L_1,t*L_2,t*L_3);
)
modgens2=()->(
L=apply(4,i->(super basis({1,0},R))*random(R^2,R^1));
test=ideal(s^2*v+t*u*L_0,s*t*v+t*u*L_1,t^2*v+t*u*L_2,t*u*L_3);
)

modgens3=()->(
L=apply(4,i->(super basis({1,0},R))*random(R^2,R^1));
test=ideal(s^2*v+t*u*L_0,s*t*v+t*u*L_1,t^2*v+t*u*L_2,t*u*s);
)

modgens4=()->(
L=apply(4,i->(super basis({1,0},R))*random(R^2,R^1));
test=ideal(s^2*v+t*u*L_0,s*t*v+t*u*L_1,t^2*v+t*u*L_2,s*t*u);
)


modgens5=()->(
L=apply(4,i->(super basis({0,0},R))*random(R^1,R^1));
test=ideal(s^2*v+t^2*u*L_0,s*t*v+t^2*u*L_1,t^2*v+t^2*u*L_2,s*t*u+t^2*u*L_3);
)

modgens6=()->(
L=apply(4,i->(super basis({0,0},R))*random(R^1,R^1));
test=ideal(s^2*v+t^2*u*L_0,s*t*v+t^2*u*L_1,t^2*v,s*t*u+t^2*u*L_3);
)


